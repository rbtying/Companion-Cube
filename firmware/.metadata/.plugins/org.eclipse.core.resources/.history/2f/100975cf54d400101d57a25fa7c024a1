#include <avr/interrupt.h>
#include <avr/pgmspace.h>
#include "WConstants.h"
#include "pins_arduino.h"
#include "txOnlySerial.h"

// Abstractions for maximum portability between processors
// These are macros to associate pins to pin change interrupts
#if !defined(digitalPinToPCICR) // Courtesy Paul Stoffregen
#if defined(__AVR_ATmega168__) || defined(__AVR_ATmega328P__)
#define digitalPinToPCICR(p)    (((p) >= 0 && (p) <= 21) ? (&PCICR) : ((uint8_t *)NULL))
#define digitalPinToPCICRbit(p) (((p) <= 7) ? 2 : (((p) <= 13) ? 0 : 1))
#define digitalPinToPCMSK(p)    (((p) <= 7) ? (&PCMSK2) : (((p) <= 13) ? (&PCMSK0) : (((p) <= 21) ? (&PCMSK1) : ((uint8_t *)NULL))))
#define digitalPinToPCMSKbit(p) (((p) <= 7) ? (p) : (((p) <= 13) ? ((p) - 8) : ((p) - 14)))
#else
#define digitalPinToPCICR(p)    ((uint8_t *)NULL)
#define digitalPinToPCICRbit(p) 0
#define digitalPinToPCMSK(p)    ((uint8_t *)NULL)
#define digitalPinToPCMSKbit(p) 0
#endif
#endif

//
// Lookup table
//
typedef struct _DELAY_TABLE {
	long baud;
	unsigned short rx_delay_centering;
	unsigned short rx_delay_intrabit;
	unsigned short rx_delay_stopbit;
	unsigned short tx_delay;
} DELAY_TABLE;

#if F_CPU == 16000000

static const DELAY_TABLE PROGMEM table[] = {
//  baud    rxcenter   rxintra    rxstop    tx
		{ 115200, 1, 17, 17, 12, }, { 57600, 10, 37, 37, 33, }, { 38400, 25,
				57, 57, 54, }, { 31250, 31, 70, 70, 68, }, { 28800, 34, 77, 77,
				74, }, { 19200, 54, 117, 117, 114, }, { 14400, 74, 156, 156,
				153, }, { 9600, 114, 236, 236, 233, }, { 4800, 233, 474, 474,
				471, }, { 2400, 471, 950, 950, 947, }, { 1200, 947, 1902, 1902,
				1899, }, { 300, 3804, 7617, 7617, 7614, }, };

const int XMIT_START_ADJUSTMENT = 5;

#elif F_CPU == 8000000

static const DELAY_TABLE table[] PROGMEM =
{
	//  baud    rxcenter    rxintra    rxstop  tx
	{	115200, 1, 5, 5, 3,},
	{	57600, 1, 15, 15, 13,},
	{	38400, 2, 25, 26, 23,},
	{	31250, 7, 32, 33, 29,},
	{	28800, 11, 35, 35, 32,},
	{	19200, 20, 55, 55, 52,},
	{	14400, 30, 75, 75, 72,},
	{	9600, 50, 114, 114, 112,},
	{	4800, 110, 233, 233, 230,},
	{	2400, 229, 472, 472, 469,},
	{	1200, 467, 948, 948, 945,},
	{	300, 1895, 3805, 3805, 3802,},
};

const int XMIT_START_ADJUSTMENT = 4;

#elif F_CPU == 20000000

// 20MHz support courtesy of the good people at macegr.com.
// Thanks, Garrett!

static const DELAY_TABLE PROGMEM table[] = {
	//  baud    rxcenter    rxintra    rxstop  tx
	{	115200, 3, 21, 21, 18,}, {57600, 20, 43, 43, 41,}, {38400, 37,
		73, 73, 70,}, {31250, 45, 89, 89, 88,}, {28800, 46, 98, 98,
		95,}, {19200, 71, 148, 148, 145,}, {14400, 96, 197, 197,
		194,}, {9600, 146, 297, 297, 294,}, {4800, 296, 595, 595,
		592,}, {2400, 592, 1189, 1189, 1186,}, {1200, 1187, 2379,
		2379, 2376,}, {300, 4759, 9523, 9523, 9520,},};

const int XMIT_START_ADJUSTMENT = 6;

#else

#error This version of NewSoftSerial supports only 20, 16 and 8MHz processors

#endif

//
// Statics
//
txSerial *txSerial::active_object = 0;

//
// Private methods
//

/* static */
inline void txSerial::tunedDelay(uint16_t delay) {
	uint8_t tmp = 0;

	asm volatile("sbiw    %0, 0x01 \n\t"
			"ldi %1, 0xFF \n\t"
			"cpi %A0, 0xFF \n\t"
			"cpc %B0, %1 \n\t"
			"brne .-10 \n\t"
			: "+r" (delay), "+a" (tmp)
			: "0" (delay)
	);
}

// This function sets the current object as the "active"
// one and returns true if it replaces another
bool txSerial::activate(void) {
	if (active_object != this) {
		uint8_t oldSREG = SREG;
		cli();
		active_object = this;
		SREG = oldSREG;
		return true;
	}

	return false;
}

void txSerial::tx_pin_write(uint8_t pin_state) {
	if (pin_state == LOW)
		*_transmitPortRegister &= ~_transmitBitMask;
	else
		*_transmitPortRegister |= _transmitBitMask;
}

//
// Constructor
//
txSerial::txSerial(uint8_t transmitPin) :
	_tx_delay(0) {
	setTX(transmitPin);
}

void txSerial::setTX(uint8_t tx) {
	pinMode(tx, OUTPUT);
	digitalWrite(tx, HIGH);
	_transmitBitMask = digitalPinToBitMask(tx);
	uint8_t port = digitalPinToPort(tx);
	_transmitPortRegister = portOutputRegister(port);
}

//
// Public methods
//

void txSerial::begin(long speed) {
	_tx_delay = 0;

	for (unsigned i = 0; i < sizeof(table) / sizeof(table[0]); ++i) {
		long baud = pgm_read_dword(&table[i].baud);
		if (baud == speed) {
			_tx_delay = pgm_read_word(&table[i].tx_delay);
			break;
		}
	}

	tunedDelay(_tx_delay); // if we were low this establishes the end

	activate();
}

void txSerial::write(uint8_t b) {
	if (_tx_delay == 0)
		return;

	activate();

	uint8_t oldSREG = SREG;
	cli();
	// turn off interrupts for a clean txmit

	// Write the start bit
	tx_pin_write(LOW);
	tunedDelay(_tx_delay + XMIT_START_ADJUSTMENT);

	for (byte mask = 0x01; mask; mask <<= 1) {
		if (b & mask) // choose bit
			tx_pin_write(HIGH); // send 1
		else
			tx_pin_write(LOW); // send 0

		tunedDelay(_tx_delay);
	}

	tx_pin_write(HIGH); // restore pin to natural state

	SREG = oldSREG; // turn interrupts back on
	tunedDelay(_tx_delay);
}

#if !defined(cbi)
#define cbi(sfr, bit) (_SFR_BYTE(sfr) &= ~_BV(bit))
#define sbi(sfr, bit) (_SFR_BYTE(sfr) |= _BV(bit))
#endif

void txSerial::enable_timer0(bool enable) {
	if (enable)
#if defined(__AVR_ATmega8__)
		sbi(TIMSK, TOIE0);
#else
		sbi(TIMSK0, TOIE0);
#endif
	else
#if defined(__AVR_ATmega8__)
		cbi(TIMSK, TOIE0);
#else
		cbi(TIMSK0, TOIE0);
#endif
}

void txSerial::flush() {
	if (active_object == this) {
		uint8_t oldSREG = SREG;
		cli();
		SREG = oldSREG;
	}
}
