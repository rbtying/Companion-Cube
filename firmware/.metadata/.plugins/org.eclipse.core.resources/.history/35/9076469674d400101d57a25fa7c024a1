#include <avr/interrupt.h>
#include <avr/pgmspace.h>
#include "WConstants.h"
#include "pins_arduino.h"
#include "txOnlySerial.h"

// 19200 baud
#if F_CPU == 16000000
const int TX_DELAY = 114;
const int XMIT_START_ADJUSTMENT = 5;
#elif F_CPU == 8000000
const int TX_DELAY = 52;
const int XMIT_START_ADJUSTMENT = 4;
#elif F_CPU == 20000000
const int TX_DELAY = 145;
const int XMIT_START_ADJUSTMENT = 6;
#else
#error This version of the Sabertooth library only supports 8Mhz/16Mhz/20Mhz processors
#endif

inline void txSerial::tunedDelay(uint16_t delay) {
	uint8_t tmp = 0;

	asm volatile("sbiw    %0, 0x01 \n\t"
			"ldi %1, 0xFF \n\t"
			"cpi %A0, 0xFF \n\t"
			"cpc %B0, %1 \n\t"
			"brne .-10 \n\t"
			: "+w" (delay), "+a" (tmp)
			: "0" (delay)
	);
}

txSerial::txSerial(uint8_t transmitPin) :
	m_tx_delay(TX_DELAY) {
	pinMode(transmitPin, OUTPUT);
	digitalWrite(transmitPin, HIGH);
	_transmitBitMask = digitalPinToBitMask(transmitPin);
	uint8_t port = digitalPinToPort(transmitPin);
	_transmitPortRegister = portOutputRegister(port);
	tunedDelay(m_tx_delay);
}

void txSerial::write(uint8_t b) {
	if (m_tx_delay == 0)
		return;

	uint8_t oldSREG = SREG;
	cli();
	*_transmitPortRegister &= ~_transmitBitMask;
	tunedDelay(m_tx_delay + XMIT_START_ADJUSTMENT);

	for (byte mask = 0x01; mask; mask <<= 1) {
		if (b & mask) // choose bit
			*_transmitPortRegister |= _transmitBitMask; // send 1
		else
			*_transmitPortRegister &= ~_transmitBitMask; // send 0
		tunedDelay(m_tx_delay);
	}

	*_transmitPortRegister |= _transmitBitMask;

	SREG = oldSREG; // turn interrupts back on
	tunedDelay(m_tx_delay);
}

#if !defined(cbi)
#define cbi(sfr, bit) (_SFR_BYTE(sfr) &= ~_BV(bit))
#define sbi(sfr, bit) (_SFR_BYTE(sfr) |= _BV(bit))
#endif
