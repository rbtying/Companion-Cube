/*
 * Controller.cpp
 *
 *  Created on: Feb 21, 2011
 *      Author: rbtying
 */

#include "StateController.h"
#include "pins.h"

StateController::StateController(control_data * ctrl, HardwareSerial * hws) {
	m_ctrl = ctrl;
	m_hws = hws;

	comm = false;
	m_poll = true;
	m_lastUpdateTime = 0;
}

/**
 * Update the buffer
 */
void StateController::update() {
	if (m_poll && (m_lastPacketSendTime - millis() > CMD_PACKET_INTERVAL)) {
		StateController::controlToRobotState(&m_ctrl, &m_state);
		StateController::sendDataPacket(&m_state);
	}

	while (m_hws->available()) {
		m_lastUpdateTime = millis();
		char c = m_hws->read();
	}
	comm = (millis() - m_lastUpdateTime) <= CMD_TIMEOUT;
}

uint8_t StateController::checksum(uint8_t * contents, uint8_t length) {
	uint32_t temp = 0;
	for (uint8_t i = 0; i < length; i++) {
		temp += contents[i];
	}
	return temp & 0b01111111;
}
//
//void StateController::sendEncoderMessage(uint8_t op, encoder_data * d,
//		uint8_t out) {
//	uint8_t buf[7];
//
//	int16_t speed = d->velocity * 100;
//	int32_t count = d->count;
//
//	buf[0] = speed >> 8u;
//	buf[1] = speed & 0xff;
//	buf[2] = count >> 24u;
//	buf[3] = count >> 16u;
//	buf[4] = count >> 8u;
//	buf[5] = count & 0xff;
//	buf[6] = out & 0xff;
//
//	sendMessage(op, buf, 7);
//}
//
//void StateController::sendEncodersMessage(uint8_t op, encoder_data * d1,
//		encoder_data * d2, uint8_t out1, uint8_t out2) {
//	uint8_t buf[14];
//	int16_t speed1 = d1->velocity * 100;
//	int32_t count1 = d1->count;
//	int16_t speed2 = d2->velocity * 100;
//	int32_t count2 = d2->count;
//
//	buf[0] = speed1 >> 8u;
//	buf[1] = speed1 & 0xff;
//	buf[2] = count1 >> 24u;
//	buf[3] = count1 >> 16u;
//	buf[4] = count1 >> 8u;
//	buf[5] = count1 & 0xff;
//	buf[6] = out1 & 0xff;
//	buf[7] = speed2 >> 8u;
//	buf[8] = speed2 & 0xff;
//	buf[9] = count2 >> 24u;
//	buf[10] = count2 >> 16u;
//	buf[11] = count2 >> 8u;
//	buf[12] = count2 & 0xff;
//	buf[13] = out2 & 0xff;
//
//	sendMessage(op, buf, 14);
//}
//
//void StateController::sendGyroMessage(uint8_t op, gyro_data * d) {
//	uint8_t buf[4];
//
//	int16_t rate = d->rate * 1000;
//	int16_t val = d->val * 1000;
//
//	buf[0] = rate >> 8u;
//	buf[1] = rate & 0xff;
//	buf[2] = val >> 8u;
//	buf[3] = val & 0xff;
//
//	sendMessage(op, buf, 4);
//}
//
//void StateController::sendBatteryMessage(uint8_t op, Battery * b) {
//	uint8_t buf[4];
//
//	int16_t v = b->getVoltage() * 100;
//	int16_t i = b->getCurrent() * 100;
//
//	buf[0] = v >> 8u;
//	buf[1] = v & 0xff;
//	buf[2] = i >> 8u;
//	buf[3] = i & 0xff;
//
//	sendMessage(op, buf, 4);
//}
//
//void StateController::sendServoMessage(uint8_t op, uint8_t angle) {
//	uint8_t buf[1];
//	buf[0] = angle;
//	sendMessage(op, buf, 1);
//}
//
//void StateController::sendServosMessage(uint8_t op, uint8_t angle1,
//		uint8_t angle2) {
//	uint8_t buf[2];
//	buf[0] = angle1;
//	buf[1] = angle2;
//	sendMessage(op, buf, 2);
//}

/**
 * Send a full data packet
 */
void StateController::sendDataPacket(robot_state * state) {
}

void robotStateToControl(robot_state * state, control_data * ctrl) {
	ctrl->pan.write(state->servo_pan_val);
	ctrl->tilt.write(state->servo_tilt_val);
	// read only values
	//	state->batt_motor_voltage * 0.01;
	//	state->batt_motor_current * 0.01;
	//	state->gyro_yaw_rate * 0.001;
	//	state->gyro_yaw_val * 0.001;
	//	state->enc_left_speed * 0.01;
	//	state->enc_right_speed * 0.01;
	//	state->enc_left_count;
	//	state->enc_right_count;
	ctrl->leftEnc.cmPerCount = state->enc_left_conv * 0.0001;
	ctrl->rightEnc.cmPerCount = state->enc_right_conv * 0.0001;
	//	more read only values
	//	state->motor_left_val;
	//	state->motor_right_val;
	ctrl->leftPID.proportional = state->pid_left_proportional * 0.01;
	ctrl->leftPID.integral = state->pid_left_integral * 0.01;
	ctrl->leftPID.derivative = state->pid_left_derivative * 0.01;
	ctrl->leftPID.set = state->pid_left_setpoint * 0.1;
	ctrl->rightPID.proportional = state->pid_right_proportional * 0.01;
	ctrl->rightPID.integral = state->pid_right_integral * 0.01;
	ctrl->rightPID.derivative = state->pid_right_derivative * 0.01;
	ctrl->rightPID.set = state->pid_right_setpoint * 0.1;
}
void controlToRobotState(control_data * ctrl, robot_state * state) {
	state->servo_pan_val = ctrl->pan.read();
	state->servo_tilt_val = ctrl->tilt.read();
	state->batt_motor_voltage = ctrl->mot_batt.getVoltage() * 100;
	state->batt_motor_current = ctrl->mot_batt.getCurrent() * 100;
	state->gyro_yaw_rate = ctrl->yaw.rate * 1000;
	state->gyro_yaw_val = ctrl->yaw.val * 1000;
	state->enc_left_speed = ctrl->leftEnc.velocity * 100;
	state->enc_right_speed = ctrl->rightEnc.velocity * 100;
	state->enc_left_count = ctrl->leftEnc.count;
	state->enc_right_count = ctrl->leftEnc.count;
	//  write only values
	//	state->enc_left_conv * 1000;
	//	state->enc_right_conv * 1000;
	state->motor_left_val = ctrl->mot.leftSpeed;
	state->motor_right_val = ctrl->mot.rightSpeed;
	//  more write only values
	//	state->pid_left_proportional * 100;
	//	state->pid_left_integral * 100;
	//	state->pid_left_derivative * 100;
	//	state->pid_left_setpoint * 0.01;
	//	state->pid_right_proportional * 100;
	//	state->pid_right_integral * 100;
	//	state->pid_right_derivative * 100;
	//	state->pid_right_setpoint * 0.01;
}

/**
 * Request a byte from Serial
 */
char StateController::nextByte(unsigned long timeout) {
	unsigned long timeOutTime = millis() + timeout;
	while (millis() < timeOutTime && !m_hws->available()) {
		// do nothing
	}
	if (m_hws->available())
		return m_hws->read();
	else
		return 0x00;
}
